package proxy

// Ref: https://github.com/cw1997/NATBypass/blob/master/nb.go

import (
	"fmt"
	"io"
	"net"
	"os"
	"os/signal"
	"strconv"
	"strings"
	"sync"
	"syscall"
	"time"

	"github.com/virink/virzz/common"
)

func startServer(addr, network string) (net.Listener, error) {
	server, err := net.Listen(network, addr)
	if err != nil {
		return nil, fmt.Errorf("listen addr [%s] faild", addr)
	}
	return server, nil
}

func acceptConn(listener net.Listener) net.Conn {
	conn, err := listener.Accept()
	if err != nil {
		common.Logger.Error("Accept local connect [%s] faild. %s", conn.RemoteAddr().String(), err.Error())
		return nil
	}
	return conn
}

func copyConn(localConn net.Conn, remoteConn net.Conn, wg *sync.WaitGroup) {
	io.Copy(localConn, remoteConn)
	localConn.Close()
	common.Logger.Normal(
		"Close the connect at local:[%s] remote:[%s]",
		localConn.LocalAddr().String(),
		localConn.RemoteAddr().String(),
	)
	wg.Done()
}

func forwardConn(localConn, remoteConn net.Conn) {
	var wg sync.WaitGroup
	wg.Add(2)
	go copyConn(localConn, remoteConn, &wg)
	go copyConn(remoteConn, localConn, &wg)
	wg.Wait()
}

func parseAddr(addr string) (string, int, error) {
	ipAndPort := strings.Split(addr, ":")
	if len(ipAndPort) != 2 {
		return "", 0, fmt.Errorf("address should be a string like [ip:port]")
	}
	ip := net.ParseIP(ipAndPort[0])
	if ip == nil {
		return "", 0, fmt.Errorf("parse ip faild")
	}
	port, err := strconv.ParseInt(ipAndPort[1], 10, 64)
	if err != nil {
		return "", 0, err
	}
	return ip.String(), int(port), nil
}

// LcxListen Listen [local port] [remote port]
func LcxListen(localPort, remotePort, timeout int) error {
	localListener, err := startServer(fmt.Sprintf("0.0.0.0:%d", localPort), "tcp")
	if err != nil {
		return err
	}
	remoteListener, err := startServer(fmt.Sprintf("0.0.0.0:%d", remotePort), "tcp")
	if err != nil {
		return err
	}
	common.Logger.Success("Listen [%d] [%d] success. waiting for client...", localPort, remotePort)

	interrupt := make(chan os.Signal, 1)
	signal.Notify(interrupt, os.Interrupt, os.Kill, syscall.SIGTERM)

	for {
		select {
		case <-interrupt:
			common.Logger.Success("Close")
			return nil
		default:
			localConn := acceptConn(localListener)
			remoteConn := acceptConn(remoteListener)
			if localConn == nil || remoteConn == nil {
				common.Logger.Error("Accept client faild. Retry in %d seconds.", timeout)
				time.Sleep(time.Duration(timeout) * time.Second)
				continue
			}
			forwardConn(localConn, remoteConn)
		}
	}
}

func localPortToRemoteAddr(localPort int, remoteIP string, remotePort int, timeout int) error {
	localListener, err := startServer(fmt.Sprintf("0.0.0.0:%d", localPort), "tcp")
	if err != nil {
		return err
	}
	for {
		localConn := acceptConn(localListener)
		if localConn == nil {
			continue
		}
		go func(targetAddr string) {
			common.Logger.Normal("Start connect host [%s]", targetAddr)
			targetDial, err := net.Dial("tcp", targetAddr)
			if err != nil {
				common.Logger.Error("Connect target [%s] faild. Retry in %d seconds", targetAddr, timeout)
				localConn.Close()
				common.Logger.Normal(
					"Close connect at local [%s] remote [%s]",
					localConn.LocalAddr().String(),
					localConn.RemoteAddr().String(),
				)
				time.Sleep(time.Duration(timeout) * time.Second)
				return
			}
			common.Logger.Normal("Connect target address [%s] success.", targetAddr)
			forwardConn(targetDial, localConn)
		}(fmt.Sprintf("%s:%d", remoteIP, remotePort))
	}
}

// LcxTran Tran
func LcxTran(localPort int, remoteHost string, remotePort int, timeout int) error {
	return localPortToRemoteAddr(localPort, remoteHost, remotePort, timeout)
}

func localAddrToRemoteAddr(localAddr, remoteAddr string, timeout int) error {
	for {
		common.Logger.Normal("Try to connect [%s] and [%s]", localAddr, remoteAddr)
		var (
			localConn, remoteConn net.Conn
			err                   error
		)
		for {
			localConn, err = net.Dial("tcp", localAddr)
			if err == nil {
				common.Logger.Normal("Connect [%s] success.", localAddr)
				break
			} else {
				common.Logger.Normal(
					"Connect target address [%s] faild. Retry in %d seconds.",
					localAddr, timeout,
				)
				time.Sleep(time.Duration(timeout) * time.Second)
			}
		}
		for {
			remoteConn, err = net.Dial("tcp", remoteAddr)
			if err == nil {
				common.Logger.Normal("Connect [%s] success.", remoteAddr)
				break
			} else {
				common.Logger.Normal(
					"Connect target address [%s] faild. Retry in %d seconds.",
					remoteAddr, timeout,
				)
				time.Sleep(time.Duration(timeout) * time.Second)
			}
		}
		forwardConn(localConn, remoteConn)
	}
}

// LcxSlave -
func LcxSlave(localAddr, remoteAddr string, timeout int) error {
	_, _, err := parseAddr(localAddr)
	if err != nil {
		return err
	}
	_, _, err = parseAddr(remoteAddr)
	if err != nil {
		return err
	}
	common.Logger.Success("Start to connect [%s] and [%s]", localAddr, remoteAddr)
	localAddrToRemoteAddr(localAddr, remoteAddr, timeout)
	return nil
}
